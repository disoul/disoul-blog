<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link href="/static/public/bower_components/material-design-lite/material.css" rel="stylesheet"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><link href="/static/public/css/article.css" rel="stylesheet"><title>Learning Advanced JavaScript 学习笔记(1)</title></head><body><div class="mdl-layout mdl-js-layout"><header class="mdl-layout__header mdl-layout__header--waterfall"><div class="mdl-layout__header-row"><a href="/" class="mdl-layout-title">My Blog</a><div class="mdl-layout-spacer"></div><div class="mdl-layout-spatfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-rightl mdl-textfield--align-right"><label for="waterfall-exp" class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons">search</i></label><div class="mdl-textfield__expandable-holder"><input type="text" name="sample" id="waterfall-exp" class="mdl-textfield__input"></div></div></div><div class="mdl-layout__header-row"><div class="mdl-layout-spacer"></div><nav class="mdl-navigation"><a href="/" class="mdl-navigation__link">Home</a><a href="/tag/index.html" class="mdl-navigation__link">Tags</a><a href="/archives/index.html" class="mdl-navigation__link">Archives</a><a href="" class="mdl-navigation__link">AboutMe</a></nav></div></header><div class="mdl-layout__drawer"><span class="mdl-layout-title">My Blog</span><nav class="mdl-navigation"><a href="/" class="mdl-navigation__link">Home</a><a href="/tag/index.html" class="mdl-navigation__link">Tags</a><a href="/archives/index.html" class="mdl-navigation__link">Archives</a><a href="" class="mdl-navigation__link">AboutMe</a></nav></div><main id="main" class="mdl-layout__content"><div class="page-content"><div id="article-block"><h2 class="title">Learning Advanced JavaScript 学习笔记(1)</h2><div class="tags"><a href="/tag/javascript.html">javascript</a><a href="/tag/web.html">web</a></div><div class="article-content"><p>首先承认自己js已经鱼到不忍直视..于是刷了一波资料..这里只是学习记录</p>
<h1>Defining Functions 定义函数</h1>
<p>第一个例子</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> canFly = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }; 
<span class="hljs-built_in">window</span>.isDeadly = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }; 
assert( isNimble() &amp;&amp; canFly() &amp;&amp; isDeadly(), <span class="hljs-string">"Still works, even though isNimble is moved."</span> ); 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNimble</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }
</code></pre>
<p>这里<code>isNimble</code>定义在第4行，但第3行依然返回true<br>
所以函数可以声明在任何位置，在运行之前js都会升级这些函数的声明<br>
@@<br>
下一个</p>
<pre><code class="language-javascript">assert( <span class="hljs-keyword">typeof</span> canFly == <span class="hljs-string">"undefined"</span>, <span class="hljs-string">"canFly doesn't get that benefit."</span> ); 
assert( <span class="hljs-keyword">typeof</span> isDeadly == <span class="hljs-string">"undefined"</span>, <span class="hljs-string">"Nor does isDeadly."</span> ); 
<span class="hljs-keyword">var</span> canFly = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; }; 
<span class="hljs-built_in">window</span>.isDeadly = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; };
</code></pre>
<p>这里2个函数在执行到1 2行的时候都是未定义，原因好像有点难理解哈。。<br>
首先一个变量是有<code>值</code>和<code>声明</code>两个概念的，对于Js来说在运行之前都会将变量的<code>声明</code>提升至相应的域，比如这个程序是在<code>global域</code><br>
如果变量在函数内就是函数的<code>local域</code>，之类的<br>
但仅仅只是<code>声明</code>提升，<code>值</code>并没有<br>
当程序执行到这个变量声明的位置时，才会将这个变量的值也提升至相应的域<br>
所以这里1 2行显示<code>undefined</code><br>
恩没错也许大概就是这样</p>
<h1>Named Functions命名函数</h1>
<p>于是栗子</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> ninja = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNinja</span>(<span class="hljs-params"></span>)</span>{ 
  assert( ninja == myNinja, <span class="hljs-string">"This function is named two things - at once!"</span> ); 
}; 
ninja(); 
assert( <span class="hljs-keyword">typeof</span> myNinja == <span class="hljs-string">"undefined"</span>, <span class="hljs-string">"But myNinja isn't defined outside of the function."</span> ); 
log( ninja );
</code></pre>
<p>这里我们可以看出，这种定义方式，在函数内部，变量名和函数名是一个概念，但是在函数外只有变量名有效</p>
<p>下一波</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> ninja = { 
  yell: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{ 
    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? ninja.yell(n<span class="hljs-number">-1</span>) + <span class="hljs-string">"a"</span> : <span class="hljs-string">"hiy"</span>; 
  } 
}; 
assert( ninja.yell(<span class="hljs-number">4</span>) == <span class="hljs-string">"hiyaaaa"</span>, <span class="hljs-string">"A single object isn't too bad, either."</span> ); 
 
<span class="hljs-keyword">var</span> samurai = { yell: ninja.yell }; 
<span class="hljs-keyword">var</span> ninja = <span class="hljs-literal">null</span>; 
 
<span class="hljs-keyword">try</span> { 
  samurai.yell(<span class="hljs-number">4</span>); 
} <span class="hljs-keyword">catch</span>(e){ 
  assert( <span class="hljs-literal">false</span>, <span class="hljs-string">"Uh, this isn't good! Where'd ninja.yell go?"</span> ); 
}
</code></pre>
<p>没错这里是一个递归，然而这货试图通过第二个变量<code>samurai</code>浅复制<code>yell</code>的递归调用<br>
然而不幸的是，这里递归调用时用的函数是<code>ninja.yell</code>自然<code>samurai</code>执行的时候<code>ninja</code>已经是<code>null</code>了<br>
于是解决方案</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> ninja = { 
  yell: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">yell</span>(<span class="hljs-params">n</span>)</span>{ 
    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? yell(n<span class="hljs-number">-1</span>) + <span class="hljs-string">"a"</span> : <span class="hljs-string">"hiy"</span>; 
  } 
}; 
assert( ninja.yell(<span class="hljs-number">4</span>) == <span class="hljs-string">"hiyaaaa"</span>, <span class="hljs-string">"Works as we would expect it to!"</span> ); 
 
<span class="hljs-keyword">var</span> samurai = { yell: ninja.yell }; 
<span class="hljs-keyword">var</span> ninja = {}; 
assert( samurai.yell(<span class="hljs-number">4</span>) == <span class="hljs-string">"hiyaaaa"</span>, <span class="hljs-string">"The method correctly calls itself."</span> );
</code></pre>
<p>给了ninja.yell一个函数名<code>yell</code>，递归调用时调用这个函数名自然也就没<code>ninja</code>什么事了<br>
还有一个比较有用的策略</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> ninja = { 
  yell: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>{ 
    <span class="hljs-keyword">return</span> n &gt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">arguments</span>.callee(n<span class="hljs-number">-1</span>) + <span class="hljs-string">"a"</span> : <span class="hljs-string">"hiy"</span>; 
  } 
}; 
</code></pre>
<p>非常有用的一个技巧<br>
<code>arguments.callee</code>代表自己这个函数，也就是调用自己进行递归</p>
<h1>Functions as Objects 函数对象</h1>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> obj = {}; 
<span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{}; 
obj.prop = <span class="hljs-string">"some value"</span>; 
fn.prop = <span class="hljs-string">"some value"</span>; 
assert( obj.prop == fn.prop, <span class="hljs-string">"Both are objects, both have the property."</span> );
</code></pre>
<p>如你所见就是这样，2者实质都是一样的，并且都有自己的<code>property</code></p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getElements</span>(<span class="hljs-params"> name </span>) </span>{ 
  <span class="hljs-keyword">var</span> results; 
 
  <span class="hljs-keyword">if</span> ( getElements.cache[name] ) { 
    results = getElements.cache[name]; 
  } <span class="hljs-keyword">else</span> { 
    results = <span class="hljs-built_in">document</span>.getElementsByTagName(name); 
    getElements.cache[name] = results; 
  } 
 
  <span class="hljs-keyword">return</span> results; 
} 
getElements.cache = {}; 
 
log( <span class="hljs-string">"Elements found: "</span>, getElements(<span class="hljs-string">"pre"</span>).length ); 
log( <span class="hljs-string">"Cache found: "</span>, getElements.cache.pre.length );
</code></pre>
<p>感觉很厉害的一种写法，给函数添加cache属性来储存缓存，思路和缓存的处理思路一样<br>
没记录查，查完存记录，有记录直接返回</p>
<p>嘛今天先到这，滚去看直播了...</p>
</div></div></div><footer class="mdl-mini-footer"><div class="mdl-mini-footer__left-section"><div class="mdl-logo"> 
My Blog <i class="material-icons">person</i> Disoul</div></div></footer></main></div></body></html><script src="/static/public/bower_components/material-design-lite/material.min.js"></script>