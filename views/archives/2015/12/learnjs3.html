<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link href="/static/public/bower_components/material-design-lite/material.css" rel="stylesheet"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><link href="/static/public/css/article.css" rel="stylesheet"><title>Learning Advanced JavaScript 学习笔记(3)</title></head><body><div class="mdl-layout mdl-js-layout"><header class="mdl-layout__header mdl-layout__header--waterfall"><div class="mdl-layout__header-row"><a href="/" class="mdl-layout-title">My Blog</a><div class="mdl-layout-spacer"></div><div class="mdl-layout-spatfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-rightl mdl-textfield--align-right"><label for="waterfall-exp" class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons">search</i></label><div class="mdl-textfield__expandable-holder"><input type="text" name="sample" id="waterfall-exp" class="mdl-textfield__input"></div></div></div><div class="mdl-layout__header-row"><div class="mdl-layout-spacer"></div><nav class="mdl-navigation"><a href="/" class="mdl-navigation__link">Home</a><a href="/tag/index.html" class="mdl-navigation__link">Tags</a><a href="/archives/index.html" class="mdl-navigation__link">Archives</a><a href="" class="mdl-navigation__link">AboutMe</a></nav></div></header><div class="mdl-layout__drawer"><span class="mdl-layout-title">My Blog</span><nav class="mdl-navigation"><a href="/" class="mdl-navigation__link">Home</a><a href="/tag/index.html" class="mdl-navigation__link">Tags</a><a href="/archives/index.html" class="mdl-navigation__link">Archives</a><a href="" class="mdl-navigation__link">AboutMe</a></nav></div><main id="main" class="mdl-layout__content"><div class="page-content"><div id="article-block"><h2 class="title">Learning Advanced JavaScript 学习笔记(3)</h2><div class="tags"><a href="/tag/web.html">web</a><a href="/tag/javascript.html">javascript</a></div><div class="article-content"><h1>Flexible Arguments 灵活的参数</h1>
<p>函数的参数也是一个学问，还是栗子</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">root</span>)</span>{ 
  <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++ ) 
    <span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-built_in">arguments</span>[i] ) 
      root[key] = <span class="hljs-built_in">arguments</span>[i][key]; 
  <span class="hljs-keyword">return</span> root; 
} 
 
<span class="hljs-keyword">var</span> merged = merge({name: <span class="hljs-string">"John"</span>}, {city: <span class="hljs-string">"Boston"</span>}); 
assert( merged.name == <span class="hljs-string">"John"</span>, <span class="hljs-string">"The original name is intact."</span> ); 
assert( merged.city == <span class="hljs-string">"Boston"</span>, <span class="hljs-string">"And the city has been copied over."</span> );
</code></pre>
<p>@@<br>
这里函数<code>merge</code>只有一个参数<code>root</code>，但在调用这个函数的时候传入了2个字典参数<br>
其中第一个<code>{name:&quot;John&quot;}</code>就是root，但第二个参数并不会被舍弃<br>
在传参时，js会把所有的参数存入一个<code>arguments</code>对象，<code>arguments</code>是一个函数作用域的对象<br>
&lt;b&gt;注意，<code>arguments</code>并不是数组，只是可以通过[i]索引访问元素&lt;/b&gt;</p>
<p>下一个栗子</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">smallest</span>(<span class="hljs-params">array</span>)</span>{ 
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min.apply( <span class="hljs-built_in">Math</span>, array ); 
} 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">largest</span>(<span class="hljs-params">array</span>)</span>{ 
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max.apply( <span class="hljs-built_in">Math</span>, array ); 
} 
assert(smallest([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) == <span class="hljs-number">0</span>, <span class="hljs-string">"Locate the smallest value."</span>); 
assert(largest([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) == <span class="hljs-number">3</span>, <span class="hljs-string">"Locate the largest value."</span>);
</code></pre>
<p>这里在函数中，通过<code>apply</code>对<code>array</code>对象调用<code>Math</code>对象的<code>min</code>或者<code>max</code>方法<br>
然而这一节说的是参数，于是下面黑魔法</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">smallest</span>(<span class="hljs-params"></span>)</span>{ 
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min.apply( <span class="hljs-built_in">Math</span>, <span class="hljs-built_in">arguments</span> ); 
} 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">largest</span>(<span class="hljs-params"></span>)</span>{ 
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.max.apply( <span class="hljs-built_in">Math</span>, <span class="hljs-built_in">arguments</span> ); 
} 
assert(smallest(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>, <span class="hljs-string">"Locate the smallest value."</span>); 
assert(largest(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) == <span class="hljs-number">3</span>, <span class="hljs-string">"Locate the largest value."</span>);
</code></pre>
<p>解释上面说过了，通过<code>arguments</code>指代参数，瞬间优雅不少<br>
下一个杨栗</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">highest</span>(<span class="hljs-params"></span>)</span>{ 
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>{ 
    <span class="hljs-keyword">return</span> b - a; 
  }); 
} 
assert(highest(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)[<span class="hljs-number">0</span>] == <span class="hljs-number">3</span>, <span class="hljs-string">"Get the highest value."</span>); 
assert(highest(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)[<span class="hljs-number">1</span>] == <span class="hljs-number">4</span>, <span class="hljs-string">"Verify the results."</span>);
</code></pre>
<p>这个程序看起来好像没问题<br>
但是运行会报错，<code>ERROR arguments.sort is not a function</code><br>
这里就和我们上面说的有关了，<code>arguments</code>并不是一个数组，而<code>sort</code>是<code>Array</code>对象的方法<br>
于是悲剧发生了，那么如何才能实现这个效果呢？<br>
让一个非<code>Array</code>对象调用<code>Array</code>对象的方法...<br>
Bingo，<code>call</code>或者<code>apply</code></p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">highest</span>(<span class="hljs-params"></span>)</span>{ 
  <span class="hljs-keyword">return</span> makeArray(<span class="hljs-built_in">arguments</span>).sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>{ 
    <span class="hljs-keyword">return</span> b - a; 
  }); 
} 
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeArray</span>(<span class="hljs-params">array</span>)</span>{ 
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Array</span>().slice.call( array ); 
} 
 
assert(highest(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)[<span class="hljs-number">0</span>] == <span class="hljs-number">3</span>, <span class="hljs-string">"Get the highest value."</span>); 
assert(highest(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)[<span class="hljs-number">1</span>] == <span class="hljs-number">4</span>, <span class="hljs-string">"Verify the results."</span>);
</code></pre>
<p>这里作者是用<code>makeArray</code>通过<code>apply</code>复制了一份<code>arguments</code>作为<code>Array</code>对象</p>
<h1>Closures 闭包</h1>
<p>说js怎么能不提闭包～<br>
什么是闭包，我的理解<br>
闭包就是这个函数加上创建这个函数时的环境<br>
关于闭包的理解我还是认为mdn写的不错，链接&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&quot;&gt;还是戳我&lt;/a&gt;<br>
下面是作者的栗子</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>; 
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addNum</span>(<span class="hljs-params">myNum</span>)</span>{ 
  <span class="hljs-keyword">return</span> num + myNum; 
} 
 
num = <span class="hljs-number">15</span>; 
 
assert( addNum(<span class="hljs-number">5</span>) == <span class="hljs-number">20</span>, <span class="hljs-string">"Add two numbers together, one from a closure."</span> );
</code></pre>
<p><code>addNum()</code>是一个基本的闭包，储存的环境就是全局参数<code>num</code><br>
这个栗子里返回的值是20，也就是说<br>
闭包储存变量的方式是通引用记录而不是值记录，所以<code>num</code>的值也随之改变了</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>; 
 
<span class="hljs-keyword">var</span> timer = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ 
  <span class="hljs-keyword">if</span> ( count &lt; <span class="hljs-number">5</span> ) { 
    log( <span class="hljs-string">"Timer call: "</span>, count ); 
    count++; 
  } <span class="hljs-keyword">else</span> { 
    assert( count == <span class="hljs-number">5</span>, <span class="hljs-string">"Count came via a closure, accessed each step."</span> ); 
    assert( timer, <span class="hljs-string">"The timer reference is also via a closure."</span> ); 
    clearInterval( timer ); 
  } 
}, <span class="hljs-number">100</span>);
</code></pre>
<p>闭包在计时器中的应用<br>
之后作者又举了一些应用，其中比较重要的，比如下面这位</p>
<pre><code class="language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Ninja</span>(<span class="hljs-params"></span>)</span>{ 
  <span class="hljs-keyword">var</span> slices = <span class="hljs-number">0</span>; 
   
  <span class="hljs-keyword">this</span>.getSlices = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ 
    <span class="hljs-keyword">return</span> slices; 
  }; 
  <span class="hljs-keyword">this</span>.slice = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ 
    slices++; 
  }; 
} 
 
<span class="hljs-keyword">var</span> ninja = <span class="hljs-keyword">new</span> Ninja(); 
ninja.slice(); 
assert( ninja.getSlices() == <span class="hljs-number">1</span>, <span class="hljs-string">"We're able to access the internal slice data."</span> ); 
assert( ninja.slices === <span class="hljs-literal">undefined</span>, <span class="hljs-string">"And the private data is inaccessible to us."</span> );
</code></pre>
<p>实现私有变量成员<code>slices</code><br>
对外接口是<code>getSlices</code>，实现了面向对象的访问控制<br>
其中<code>getSlices</code>就是一个闭包函数，因为js的作用域链，<code>getSlices</code>内可以访问<code>slices</code>,而在外部则不能，从而实现效果<br>
嘛如果是公有变量直接写成<code>this.slices</code>即可</p>
<p>睡觉...</p>
</div></div></div><footer class="mdl-mini-footer"><div class="mdl-mini-footer__left-section"><div class="mdl-logo"> 
My Blog <i class="material-icons">person</i> Disoul</div></div></footer></main></div></body></html><script src="/static/public/bower_components/material-design-lite/material.min.js"></script>