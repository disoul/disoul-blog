<!DOCTYPE html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link href="/static/public/bower_components/material-design-lite/material.css" rel="stylesheet"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><link href="/static/public/css/article.css" rel="stylesheet"><title>使用cocos2dx-x3.0的物理引擎实现碰撞检测</title></head><body><div class="mdl-layout mdl-js-layout"><header class="mdl-layout__header mdl-layout__header--waterfall"><div class="mdl-layout__header-row"><a href="/" class="mdl-layout-title">My Blog</a><div class="mdl-layout-spacer"></div><div class="mdl-layout-spatfield mdl-js-textfield mdl-textfield--expandable mdl-textfield--floating-label mdl-textfield--align-rightl mdl-textfield--align-right"><label for="waterfall-exp" class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons">search</i></label><div class="mdl-textfield__expandable-holder"><input type="text" name="sample" id="waterfall-exp" class="mdl-textfield__input"></div></div></div><div class="mdl-layout__header-row"><div class="mdl-layout-spacer"></div><nav class="mdl-navigation"><a href="/" class="mdl-navigation__link">Home</a><a href="/tag/index.html" class="mdl-navigation__link">Tags</a><a href="/archives/index.html" class="mdl-navigation__link">Archives</a><a href="" class="mdl-navigation__link">AboutMe</a></nav></div></header><div class="mdl-layout__drawer"><span class="mdl-layout-title">My Blog</span><nav class="mdl-navigation"><a href="/" class="mdl-navigation__link">Home</a><a href="/tag/index.html" class="mdl-navigation__link">Tags</a><a href="/archives/index.html" class="mdl-navigation__link">Archives</a><a href="" class="mdl-navigation__link">AboutMe</a></nav></div><main id="main" class="mdl-layout__content"><div class="page-content"><div id="article-block"><h2 class="title">使用cocos2dx-x3.0的物理引擎实现碰撞检测</h2><div class="tags"><a href="/tag/cocos2dx.html">cocos2dx</a></div><div class="article-content"><p>前几天帮人写了一个小游戏因为传统rect碰撞检测写起来太麻烦于是研究了下自带的物理引擎碰撞检测</p>
<p>##首先创建物理世界</p>
<p>在.h文件添加如下代码</p>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setPhyWorld</span><span class="hljs-params">(PhysicsWorld* world)</span></span>{m_world = world;}
<span class="hljs-keyword">private</span>:
    PhysicsWorld* m_world;
</code></pre>
<p>其中第一行中可以添加代码来规定物理世界的一些属性<br>
如 重力</p>
<pre><code class="language-c++">m_world-&gt;setGravity(Vec2(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)); <span class="hljs-comment">//取消重力</span>
</code></pre>
<h2>@@</h2>
<p>在.cpp文件添加如下代码</p>
<pre><code class="language-c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-string">"HelloWorldScene.h"</span></span>

Scene* HelloWorld::createScene()
{
    <span class="hljs-keyword">auto</span> scene = Scene::createWithPhysics();
    scene-&gt;getPhysicsWorld()-&gt;setDebugDrawMask(PhysicsWorld::DEBUGDRAW_ALL);<span class="hljs-comment">//开启DEBUG模式，会绘制模型边缘关节等</span>
    <span class="hljs-keyword">auto</span> layer = HelloWorld::create();
    layer-&gt;setPhyWorld(scene-&gt;getPhysicsWorld());
    scene-&gt;addChild(layer);
    <span class="hljs-keyword">return</span> scene;   
}
<span class="hljs-keyword">bool</span> HelloWorld::init()
{
    <span class="hljs-keyword">if</span> ( !Layer::init() )
    {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>通过createWithPhysics()方法创建一个带有物理效果的Scene，然后将需要添加物理效果的层加入其中</p>
<p>##创建物理边界</p>
<pre><code class="language-c++">Size visibleSize = Director::getInstance()-&gt;getVisibleSize();
<span class="hljs-keyword">auto</span> body = PhysicsBody::createEdgeBox(visibleSize, PHYSICSBODY_MATERIAL_DEFAULT, <span class="hljs-number">3</span>);
<span class="hljs-keyword">auto</span> edgeNode = Node::create();
edgeNode-&gt;setPosition(Point(visibleSize.width/<span class="hljs-number">2</span>,visibleSize.height/<span class="hljs-number">2</span>));
edgeNode-&gt;setPhysicsBody(body);
scene-&gt;addChild(edgeNode);
</code></pre>
<p>PhysicsWorld有很多工厂方法，如createEdgeBox创建一个矩形的边框，所有的参数是：</p>
<ul>
<li>矩形区域，设置作为visibleSize</li>
<li>可选参数，纹理，默认为PHYSICSBODY_MATERIAL_DEFAULT</li>
<li>可选参数，边框大小，默认为1</li>
</ul>
<p>##设置精灵为刚体</p>
<p>和大多数物理引擎一样，物件只有成为刚体才能受到物理世界的影响</p>
<pre><code class="language-c++"><span class="hljs-keyword">void</span> HelloWorld::addBoxBodyForSprite(Sprite* sprite)
{
	<span class="hljs-keyword">auto</span> body = PhysicsBody::createBox(sprite-&gt;getContentSize());
	body-&gt;setDynamic(<span class="hljs-literal">true</span>);

	body-&gt;setContactTestBitmask(<span class="hljs-number">0xFFFFFFFF</span>); <span class="hljs-comment">//设置刚体的接触测试掩码，即所有掩码位为1</span>
	sprite-&gt;setPhysicsBody(body);
}
</code></pre>
<p>如果两个物体的接触测试掩码（ContactTestBitmask）执行“逻辑与”运算，如果结果为非零值，表明这两个物体会触发碰撞检测事件。默认值是0x00000000，表示清除所有掩码位，0xFFFFFFFF表示所有掩码位都设置为1。<br>
除了接触测试掩码（ContactTestBitmask）外，物理引擎中还定义了类别掩码（CategoryBitmask）和碰撞掩码（CollisionBitmask），它们的作用是当两个物体接触时候是否发生“碰撞反应”，“碰撞反应”会表现为一个物体受到另外物体的碰撞，而改变运动方向。由于两个物体是“刚体”，在碰撞的时候两个物体不会交叉。</p>
<ul>
<li>类别掩码 body-&gt;setCategoryBitmask(int bitmask)</li>
<li>碰撞掩码 body-&gt;setCollisionBitmask(int bitmask)</li>
<li>接触测试掩码 body-&gt;setContactTestBitmask(int bitmask)</li>
</ul>
<p>类别掩码（CategoryBitmask）与碰撞掩码（CollisionBitmask）决定了物体能否发生“碰撞反应”。而接触测试掩码（ContactTestBitmask）的设置，能够检测是否发生接触发生，并且触发EventListenerPhysicsContact监听事件。 接触测试掩码与类别掩码和碰撞掩码没有什么关联。</p>
<p>##注册碰撞监听事件</p>
<p>Cocos2d-x3.0中，事件派发机制做了重构，所有事件均有事件派发器统一管理。物理引擎的碰撞事件也不例外<br>
下面的代码注册碰撞begin回调函数。</p>
<pre><code class="language-c++"><span class="hljs-keyword">void</span> HelloWorld::onEnter()
{
    Layer::onEnter();

    <span class="hljs-keyword">auto</span> contactListener = EventListenerPhysicsContact::create();
    contactListener-&gt;onContactBegin = CC_CALLBACK_2(HelloWorld::onContactBegin, <span class="hljs-keyword">this</span>);

    <span class="hljs-keyword">auto</span> dispatcher = Director::getInstance()-&gt;getEventDispatcher();

    dispatcher-&gt;addEventListenerWithSceneGraphPriority(contactListener, <span class="hljs-keyword">this</span>);
}

<span class="hljs-keyword">bool</span> HelloWorld::onContactBegin(EventCustom* event, <span class="hljs-keyword">const</span> PhysicsContact&amp; contact)
{
    <span class="hljs-keyword">auto</span> spriteA = (Sprite*)contact.getShapeA()-&gt;getBody()-&gt;getNode();
    <span class="hljs-keyword">auto</span> spriteB = (Sprite*)contact.getShapeB()-&gt;getBody()-&gt;getNode();

    CCLOG(<span class="hljs-string">"Contact!!"</span>);

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</code></pre>
<p>如果一切顺利精灵碰撞时将会打印Contact！<br>
这里根据cocos2dx版本的不同回调函数回有所不同，在我测试的r1版本里，onContactBegin函数没有event参数<br>
所以注册回调函数的时候使用 CC_CALLBACK_1</p>
</div></div></div><footer class="mdl-mini-footer"><div class="mdl-mini-footer__left-section"><div class="mdl-logo"> 
My Blog <i class="material-icons">person</i> Disoul</div></div></footer></main></div></body></html><script src="/static/public/bower_components/material-design-lite/material.min.js"></script>